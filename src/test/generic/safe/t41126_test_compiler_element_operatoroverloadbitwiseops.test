## -*- mode:ulam -*-
#=t41126_test_compiler_element_operatoroverloadbitwiseops
##
##  gen code output: (+ interleaved asserts)
##	 Unsigned Arg: 5
##	 Unsigned Arg: 1
##	 Unsigned Arg: 4
##
#!
Exit status: 4
Ue_Foo { Bool first(false);  Bits m_it(0);  Int(4) m_i(0);  Int test() {  System s;  Foo f;  f ( 5u cast )operator| . s ( f m_it . cast )print . s ( f m_it . 5u cast == )assert . f ( 3u cast )operator& . s ( f m_it . cast )print . s ( f m_it . 1u cast == )assert . f ( 5u cast )operator^ . s ( f m_it . cast )print . s ( f m_it . 4u cast == )assert . f m_it . cast return } }
Uq_System { <NOMAIN> }
##
## first test to parse bitwise overload operator for an element
## informed by t41121.
##
#>Foo.ulam
  ulam 3;
element Foo {
  Bool first;
  Bits m_it;
  Int(4) m_i;
  Int test() {
    System s;
    Foo f;

    f | 5u;
    s.print((Unsigned) f.m_it); //prints 5
    s.assert(f.m_it == 0x5);

    f & 3u;
    s.print((Unsigned) f.m_it); //prints 1
    s.assert(f.m_it == 0x1);

    f ^ 5u;
    s.print((Unsigned) f.m_it); //prints 4
    s.assert(f.m_it == 0x4);

    return (Int) f.m_it;
  }

  //7c
  Void operator|(Unsigned arg)
  {
    m_it |= arg;
  }

  //26
  Void operator&(Unsigned arg)
  {
    m_it &= arg;
  }

  //5e
  Void operator^(Unsigned arg)
  {
    m_it ^= arg;
  }

}

#:System.ulam
  ulam 1;
quark System {
Void print(Unsigned arg) native;
Void print(Int arg) native;
Void print(Int(4) arg) native;
Void print(Int(3) arg) native;
Void print(Unary(3) arg) native;
Void print(Bool(3) arg) native;
Void assert(Bool b) native;
}

#.
