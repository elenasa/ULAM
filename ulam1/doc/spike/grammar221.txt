<PROGRAM> := <PROGRAM_DEF>* + <EOF>
<PROGRAM_DEF> := <QUARK_OR_UNION_DEF> | <ELEMENT_DEF>
<ELEMENT_DEF> := 'element' + <TYPE_IDENT> + <CLASS_BLOCK>
<QUARK_OR_UNION_DEF> := ('quark' | 'union') + <TYPE_IDENT> + <CLASS_BLOCK>
<CLASS_BLOCK> := '{' + <DATA_MEMBERS> + '}'
<DATA_MEMBERS> := ( 0 | <FUNC_DEF> | ('element' | 0 ) + <DECL> + ';' | <TYPE_DEF> + ';' )*

<DECL> := <TYPE> + <VAR_DECLS>
<VAR_DECLS> := <VAR_DECL> | <VAR_DECL> + ',' + <VAR_DECLS>
<VAR_DECL> := <LVAL_EXPRESSION>

<STATEMENT_DECL> := <TYPE> + <VAR_STATEMENT_DECLS>
<VAR_STATEMENT_DECLS> := <VAR_STATEMENT_DECL> | <VAR_STATEMENT_DECL> + ',' + <VAR_STATEMENT_DECLS>
<VAR_STATEMENT_DECL> := <LVAL_EXPRESSION> + ( 0 | '=' + <ASSIGN_EXPRESSION> )

<TYPE_NAME> := 'Int' | 'Unsigned' | 'Bool' | 'Unary' | 'Bits' | <TYPE_IDENT>
<TYPE> := <TYPE_NAME> | <TYPE_NAME> + '(' + <EXPRESSION> + ')'
<TYPE_DEF> := 'typedef' + <TYPE> + <TYPE_EXPRESSION>
<TYPE_EXPRESSION> := <TYPE_IDENT> | <TYPE_IDENT> + '[' + <EXPRESSION> + ']'

<FUNC_DEF> := <ULAM_FUNC_DEF> | <NATIVE_FUNC_DEF>
<ULAM_FUNC_DEF> := <FUNC_DECL> + <BLOCK>
<NATIVE_FUNC_DEF> := <FUNC_DECL> + 'native' + ';'

<FUNC_DECL> := <TYPE> + <IDENT> + '(' + <FUNC_PARAM_DECLS> + ')'
<FUNC_PARAM_DECLS> := 0 | '...' | <FUNC_PARAMS> | <FUNC_PARAMS> + ',' + '...'
<FUNC_PARAMS> := <FUNC_PARAM> | <FUNC_PARAM> + ',' + <FUNC_PARAMS>
<FUNC_PARAM>  := <TYPE> + <VAR_DECL>

<BLOCK> := '{' + <STATEMENTS> + '}'
<STATEMENTS> := 0 | <STATEMENT> + <STATEMENTS>
<STATEMENT> := <SIMPLE_STATEMENT> | <CONTROL_STATEMENT> | <BLOCK>

<CONTROL_STATEMENT> := <IF_STATEMENT> | <WHILE_STATEMENT> | <FOR_STATEMEMT> | <BREAK_STATEMENT> | <CONTINUE_STATEMENT> 
<IF_STATEMENT> := 'if' + '(' + <CONDITIONAL_EXPRESSION> + ') + <STATEMENT> + <OPT_ELSE_STATEMENT>
<OPT_ELSE_STATEMENT> := 0 | 'else' + <STATEMENT>

<CONDITIONAL_EXPRESSION> := <SIMPLE_COND_DECL> | <ASSIGN_EXPESSION>
<SIMPLE_COND_DECL> := <IDENT> + 'as' + <TYPE_IDENT>

<FOR_STATEMENT> := 'for' + '(' + ( 0 | <STATEMENT_DECL>) + ';'
                               + ( 0 | <CONDITIONAL_EXPRESSION>) + ';'
                               + ( 0 | <ASSIGN_EXPRESSION>) + ')'
                               + <STATEMENT>

  => equiv to a parse tree shaped like: { <STATEMENT_DECL>  while ( <CONDITIONAL_EXPRESSION> ) { <STATEMENT> <ASSIGN_EXPRESSION> } }

<WHILE_STATEMENT> := 'while' + '(' + <CONDITIONAL_EXPRESSION> + ')' + <STATEMENT>
<BREAK_STATEMENT> := 'break' + ';'
<CONTINUE_STATEMENT> := 'continue' + ';'

<SIMPLE_STATEMENT> := ( 0 | <STATEMENT_DECL> | <TYPE_DEF> | <ASSIGN_EXPRESSION>
                          | <RETURN_STATEMENT> ) + ';'
<RETURN_STATEMENT> := 'return' + ( 0 | <ASSIGN_EXPRESSION>)

<ASSIGN_EXPRESSION> := <EXPRESSION> | <LVAL_EXPRESSION> + <ASSIGN_OP> + <ASSIGN_EXPRESSION>
<ASSIGN_OP> := '=' | '+=' | '-=' | '*=' | '&=' | '|=' | '^='

<LVAL_EXPRESSION> := <IDENT> | <IDENT> + '[' + <EXPRESSION> + ']'
<IDENT_EXPRESSION> := <LVAL_EXPRESSION> | <FUNC_CALL> | <MEMBER_SELECT_EXPRESSION>

<FUNC_CALL> := <IDENT> + '(' + <ARGS> + ')'
<ARGS> := 0 | <ARG> | <ARG> + ',' + <ARGS>
<ARG>  := <ASSIGN_EXPRESSION>

<MEMBER_SELECT_EXPRESSION> := <IDENT_EXPRESSION> + '.' + <IDENT_EXPRESSION>

<EXPRESSION> := <LOGICAL_EXPRESSION> | <EXPRESSION> <LOGICALOP> <LOGICAL_EXPRESSION>
<LOGICALOP> := '&&' | '||'
<LOGICAL_EXPRESSION> := <BIT_EXPRESSION> | <LOGICAL_EXPRESSION> <BITOP> <BIT_EXPRESSION>
<BITOP> := '&' | '|' | '^'
<BIT_EXPRESSION> := <EQ_EXPRESSION> | <BIT_EXPRESSION> <EQOP> <EQ_EXPRESSION>
<EQOP> := '==' | '!='
<EQ_EXPRESSION> := <COMPARE_EXPRESSION> | <EQ_EXPRESSION> <COMPOP> <COMPARE_EXPRESSION>
<COMPOP> := '<' | '>' | '<=' | '>='
<COMPARE_EXPRESSION> := <SHIFT_EXPRESSION> | <COMPARE_EXPRESSION> <SHIFTOP> <SHIFT_EXPRESSION>
<SHIFTOP> := '<<' | '>>'
<SHIFT_EXPRESSION> := <TERM> | <SHIFT_EXPRESSION> <ADDOP> <TERM>
<ADDOP> := '+' | '-'
<TERM> := <FACTOR> | <TERM> <MULOP> <FACTOR>
<MULOP> := '*' | '/' | '%'
<FACTOR> := <IDENT_EXPRESSION> | <NUMBER> | '(' + <ASSIGN_EXPRESSION> + ')' | <UNOP_EXPRESSION>
<UNOP_EXPRESSION> := <UNOP> + <FACTOR> | <IDENT_EXPRESSION> + ('is' | 'has') + <TYPE_IDENT>
<UNOP> := '-' | '+' | '!' | <CAST>
<CAST> := '(' + <TYPE> + ')'

<TYPE_IDENT> := /^[A-Z][A-Za-z0-9\_]*/
<IDENT> := /^[a-z][A-Za-z0-9\_]*/
[use newlines per line for genCode comments]
